{"file": "src/ui/components/QueueBattleView.tsx", "search": "  const handleTargetSelect = (targetId: string) => {\n    if (!currentUnit || activePortraitIndex === null || !battle) return;\n\n    const ability = currentUnit.abilities.find(a => a.id === selectedAbilityId);\n    \n    // Resolve target list based on ability target type\n    let targetIds: string[] = [targetId];\n    const aliveEnemies = battle.enemies.filter((e) => !isUnitKO(e)).map((e) => e.id);\n    const aliveAllies = battle.playerTeam.units.filter((u) => !isUnitKO(u)).map((u) => u.id);\n\n    switch (ability?.targets) {\n      case 'all-enemies':\n        targetIds = aliveEnemies;\n        break;\n      case 'all-allies':\n        targetIds = aliveAllies;\n        break;\n      case 'self':\n        targetIds = [currentUnit.id];\n        break;\n      default:\n        targetIds = [targetId];\n    }\n\n    // Queue the action\n    const queued = queueUnitAction(activePortraitIndex, selectedAbilityId ?? null, targetIds, ability);\n    if (!queued) {\n      return;\n    }\n\n    // Crit counter progression for basic attacks\n    if (selectedAbilityId === null) {\n      const nextCount = (critCounters[currentUnit.id] ?? 0) + 1;\n      const threshold = critThresholds[currentUnit.id] ?? 10;\n      if (nextCount >= threshold) {\n        resetCritCounter(currentUnit.id);\n        triggerCritFlash(currentUnit.id);\n      } else {\n        incrementCritCounter(currentUnit.id);\n      }\n    }\n    \n    // Reset selection for next\n    setSelectedAbilityId(undefined);\n\n    // Auto-advance to next unit by SPEED\n    const order = getPlanningTurnOrder(battle);\n    const currentOrderIdx = order.indexOf(activePortraitIndex);\n    if (currentOrderIdx !== -1 && currentOrderIdx < order.length - 1) {\n      const nextIndex = order[currentOrderIdx + 1];\n      if (nextIndex !== undefined) {\n        setActivePortrait(nextIndex);\n      }\n    }\n  };\n\n  const handleExecute = () => {\n    if (isQueueComplete) executeQueuedRound();\n  };", "replace": "  const handleTargetSelect = (targetId: string, abilityIdOverride?: string | null) => {\n    if (!currentUnit || activePortraitIndex === null || !battle) return;\n\n    const abilityIdToUse = abilityIdOverride ?? selectedAbilityId;\n    const ability = abilityIdToUse ? currentUnit.abilities.find(a => a.id === abilityIdToUse) : undefined;\n    \n    // Resolve target list based on ability target type\n    let targetIds: string[] = [targetId];\n    const aliveEnemies = battle.enemies.filter((e) => !isUnitKO(e)).map((e) => e.id);\n    const aliveAllies = battle.playerTeam.units.filter((u) => !isUnitKO(u)).map((u) => u.id);\n\n    switch (ability?.targets) {\n      case 'all-enemies':\n        targetIds = aliveEnemies;\n        break;\n      case 'all-allies':\n        targetIds = aliveAllies;\n        break;\n      case 'self':\n        targetIds = [currentUnit.id];\n        break;\n      default:\n        targetIds = [targetId];\n    }\n\n    // Queue the action\n    const queued = queueUnitAction(activePortraitIndex, abilityIdToUse ?? null, targetIds, ability);\n    if (!queued) {\n      return;\n    }\n\n    // Crit counter progression for basic attacks\n    if (abilityIdToUse === null) {\n      const nextCount = (critCounters[currentUnit.id] ?? 0) + 1;\n      const threshold = critThresholds[currentUnit.id] ?? 10;\n      if (nextCount >= threshold) {\n        resetCritCounter(currentUnit.id);\n        triggerCritFlash(currentUnit.id);\n      } else {\n        incrementCritCounter(currentUnit.id);\n      }\n    }\n    \n    // Reset selection for next\n    setSelectedAbilityId(undefined);\n\n    // Auto-advance to next unit by SPEED\n    const order = getPlanningTurnOrder(battle);\n    const currentOrderIdx = order.indexOf(activePortraitIndex);\n    if (currentOrderIdx !== -1 && currentOrderIdx < order.length - 1) {\n      const nextIndex = order[currentOrderIdx + 1];\n      if (nextIndex !== undefined) {\n        setActivePortrait(nextIndex);\n      }\n    }\n  };\n\n  const handleAutoAttack = () => {\n    if (!battle || battle.phase !== 'planning') return;\n    if (!currentUnit || activePortraitIndex === null) return;\n    if (isUnitKO(currentUnit)) return;\n\n    const targets = getValidTargets(null, currentUnit, battle.playerTeam, battle.enemies);\n    if (!targets.length) return;\n\n    handleSelectAttack();\n    handleTargetSelect(targets[0].id, null);\n  };\n\n  useEffect(() => {\n    const onKeyDown = (event: KeyboardEvent) => {\n      if (event.key !== 'q' && event.key !== 'Q') return;\n      if (event.repeat) return;\n      handleAutoAttack();\n    };\n\n    window.addEventListener('keydown', onKeyDown);\n    return () => {\n      window.removeEventListener('keydown', onKeyDown);\n    };\n  }, [handleAutoAttack]);\n\n  const handleExecute = () => {\n    if (isQueueComplete) executeQueuedRound();\n  };"}
